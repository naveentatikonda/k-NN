diff --git a/faiss/impl/ScalarQuantizer.cpp b/faiss/impl/ScalarQuantizer.cpp
index a3cf4c74..28d63851 100644
--- a/faiss/impl/ScalarQuantizer.cpp
+++ b/faiss/impl/ScalarQuantizer.cpp
@@ -26,6 +26,9 @@
 #include <faiss/utils/fp16.h>
 #include <faiss/utils/utils.h>
 
+#include <iostream>
+#include <fstream>
+
 namespace faiss {
 
 /*******************************************************************
@@ -167,7 +170,6 @@ struct Codec6bit {
     }
 
 #ifdef __AVX2__
-
     /* Load 6 bytes that represent 8 6-bit values, return them as a
      * 8*32 bit vector register */
     static __m256i load6(const uint16_t* code16) {
@@ -249,7 +251,6 @@ struct QuantizerTemplate<Codec, true, 1> : ScalarQuantizer::SQuantizer {
 };
 
 #ifdef __AVX2__
-
 template <class Codec>
 struct QuantizerTemplate<Codec, true, 8> : QuantizerTemplate<Codec, true, 1> {
     QuantizerTemplate(size_t d, const std::vector<float>& trained)
@@ -333,8 +334,11 @@ struct QuantizerFP16<1> : ScalarQuantizer::SQuantizer {
     QuantizerFP16(size_t d, const std::vector<float>& /* unused */) : d(d) {}
 
     void encode_vector(const float* x, uint8_t* code) const final {
-        for (size_t i = 0; i < d; i++) {
+	    //std::cout << "Naveen: Inside <1> encode_vector" << std::flush;
+	    //std::cout << "Naveen: Encoded vector values: " << std::flush;
+	for (size_t i = 0; i < d; i++) {
             ((uint16_t*)code)[i] = encode_fp16(x[i]);
+	   // std::cout << encode_fp16(x[i]) << ", " << std::flush;
         }
     }
 
@@ -364,6 +368,76 @@ struct QuantizerFP16<8> : QuantizerFP16<1> {
 
 #endif
 
+/*
+#ifdef __aarch64__
+
+template <>
+struct QuantizerFP16<8> : QuantizerFP16<1> {
+    QuantizerFP16(size_t d, const std::vector<float>& trained)
+	    : QuantizerFP16<1>(d, trained) {}
+
+    float32x4_t reconstruct_8_components(const uint8_t* code, int i) const {
+	    //std::cout << "Naveen: Inside <8> reconstruct_component" << std::flush;
+	    //int32x4_t codei = vld1q_s32((const int32_t*)(code + 2 * i)); // TODO: (const int32_t*) or (const int32x4_t*)
+            //return vreinterpretq_f32_s32(codei);
+	    //int16x4_t codei = vld1_s16((const int16_t*)(code + 2 * i));
+	    //return vreinterpretq_f32_s32(vmovl_s16(codei));
+	    uint16x4_t codei = vld1_u16((const uint16_t*)(code + 2 * i));
+	    uint16_t(*ArrPtr)[4] = (uint16_t(*)[4])&codei;
+	    std::cout << " Naveen: reconstruct_8_component code values: " << std::flush;
+	    for (int32_t i = 0; i < 4; i++)
+            std::cout << *((*ArrPtr)+i) << ", " << std::flush;		    
+	    
+	    
+	    //float16x4_t temp = vreinterpret_f16_u16(codei);
+            //float(*ArrPtr1)[4] = (float(*)[4])&temp; 
+            //std::cout << " Naveen: reconstruct_8_component temp values: " << std::flush;
+	    //for (int32_t i = 0; i < 4; i++)
+	    //std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+	    return vcvt_f32_f16(vreinterpret_f16_u16(codei));
+
+	    //return vreinterpretq_f32_u32(vmovl_u16(codei));
+    }
+};
+#endif */
+
+#ifdef __aarch64__
+
+template <>
+struct QuantizerFP16<8> : QuantizerFP16<1> {
+	QuantizerFP16(size_t d, const std::vector<float>& trained)
+		: QuantizerFP16<1>(d, trained) {}
+
+	float32x4x2_t reconstruct_8_components(const uint8_t* code, int i) const {
+		uint16x4x2_t codei = vld2_u16((const uint16_t*)(code + 2 * i));
+		//return vzipq_f32(vcvt_f32_f16(vreinterpret_f16_u16(codei.val[0])), vcvt_f32_f16(vreinterpret_f16_u16(codei.val[1])));
+	        
+		/*float32x4_t d1 = vcvt_f32_f16(vreinterpret_f16_u16(codei.val[0]));
+		float32x4_t d2 = vcvt_f32_f16(vreinterpret_f16_u16(codei.val[1]));
+		float(*ArrPtr1)[4] = (float(*)[4])&d1;
+		std::cout << " Naveen: reconstruct_8_component d1 values: " << std::flush;
+                for (int32_t i = 0; i < 4; i++)
+                std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+		
+                float(*ArrPtr2)[4] = (float(*)[4])&d2;
+		std::cout << " Naveen: reconstruct_8_component d2 values: " << std::flush;
+	        for (int32_t i = 0; i < 4; i++)
+		std::cout << *((*ArrPtr2)+i) << ", " << std::flush;
+                */ 
+
+		/*float32x4x2_t dummy = vzipq_f32(vcvt_f32_f16(vreinterpret_f16_u16(codei.val[0])), vcvt_f32_f16(vreinterpret_f16_u16(codei.val[1])));
+		float(*ArrPtr1)[8] = (float(*)[8])&dummy; 
+		std::cout << " Naveen: reconstruct_8_component dummy values: " << std::flush;
+		for (int32_t i = 0; i < 8; i++)
+			std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+		*/
+		//return vcvt_f32_f16(vreinterpret_f16_u16(codei.val[1]));
+		return vzipq_f32(vcvt_f32_f16(vreinterpret_f16_u16(codei.val[0])), vcvt_f32_f16(vreinterpret_f16_u16(codei.val[1])));
+	}
+};
+#endif
+
+
 /*******************************************************************
  * 8bit_direct quantizer
  *******************************************************************/
@@ -411,31 +485,33 @@ struct Quantizer8bitDirect<8> : Quantizer8bitDirect<1> {
 
 #endif
 
-template <int SIMDWIDTH>
+template <int SIMDWIDTH, int SIMDWIDTH_DEFAULT>
 ScalarQuantizer::SQuantizer* select_quantizer_1(
         QuantizerType qtype,
         size_t d,
         const std::vector<float>& trained) {
     switch (qtype) {
         case ScalarQuantizer::QT_8bit:
-            return new QuantizerTemplate<Codec8bit, false, SIMDWIDTH>(
+            return new QuantizerTemplate<Codec8bit, false, SIMDWIDTH_DEFAULT>(
                     d, trained);
         case ScalarQuantizer::QT_6bit:
-            return new QuantizerTemplate<Codec6bit, false, SIMDWIDTH>(
+            return new QuantizerTemplate<Codec6bit, false, SIMDWIDTH_DEFAULT>(
                     d, trained);
         case ScalarQuantizer::QT_4bit:
-            return new QuantizerTemplate<Codec4bit, false, SIMDWIDTH>(
+            return new QuantizerTemplate<Codec4bit, false, SIMDWIDTH_DEFAULT>(
                     d, trained);
         case ScalarQuantizer::QT_8bit_uniform:
-            return new QuantizerTemplate<Codec8bit, true, SIMDWIDTH>(
-                    d, trained);
+            return new QuantizerTemplate<Codec8bit, true, SIMDWIDTH_DEFAULT>(
+                    d, trained);		    
         case ScalarQuantizer::QT_4bit_uniform:
-            return new QuantizerTemplate<Codec4bit, true, SIMDWIDTH>(
+            return new QuantizerTemplate<Codec4bit, true, SIMDWIDTH_DEFAULT>(
                     d, trained);
         case ScalarQuantizer::QT_fp16:
-            return new QuantizerFP16<SIMDWIDTH>(d, trained);
+	    //std::cout << "Naveen: Inside <SIMDWIDTH> QT_fp16 switch case" << std::flush; 
+	    return new QuantizerFP16<SIMDWIDTH>(d, trained);
         case ScalarQuantizer::QT_8bit_direct:
-            return new Quantizer8bitDirect<SIMDWIDTH>(d, trained);
+            return new Quantizer8bitDirect<SIMDWIDTH_DEFAULT>(d, trained);
+	    
     }
     FAISS_THROW_MSG("unknown qtype");
 }
@@ -648,7 +724,11 @@ struct SimilarityL2<1> {
     }
 
     float result() {
-        return accu;
+	std::cout << "Naveen: Result is: " << accu << std::flush;
+	  /*  std::ofstream MyFile;
+	    MyFile.open("/home/ec2-user/k-NN/compute_distance.txt", std::ios_base::app);
+	    MyFile << accu << "\n";*/
+	return accu;
     }
 };
 
@@ -691,6 +771,205 @@ struct SimilarityL2<8> {
 
 #endif
 
+/*
+#ifdef __aarch64__
+template <>
+struct SimilarityL2<8> {
+    static constexpr int simdwidth = 8; 
+    static constexpr MetricType metric_type = METRIC_L2;
+					   
+    const float *y, *yi;
+
+    explicit SimilarityL2(const float* y) : y(y) {}
+    float32x4_t accu8;
+    void begin_8() {
+	    accu8 = vdupq_n_f32(0.0f);
+	    yi = y;
+    }
+
+    void add_8_components(float32x4_t x) {
+	    //std::cout << "Naveen: Inside L2<8> add_8_components" << std::flush;
+	float32x4_t yiv = vld1q_f32(yi);
+        yi += 4;
+	float32x4_t tmp = vsubq_f32(yiv, x);
+
+	float(*ArrPtr1)[4] = (float(*)[4])&tmp;
+	std::cout << " Naveen: tmp values: " << std::flush;
+	for (int32_t i = 0; i < 4; i++)
+	std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+
+        float(*ArrPtr2)[4] = (float(*)[4])&x;
+	std::cout << " Naveen: x values: " << std::flush;
+	for (int32_t i = 0; i < 4; i++)
+	std::cout << *((*ArrPtr2)+i) << ", " << std::flush;	
+
+        accu8 = vaddq_f32(accu8, vmulq_f32(tmp, tmp));
+        
+	float(*ArrPtr)[4] = (float(*)[4])&accu8;
+	std::cout << " Naveen: Accumulator values: " << std::flush;
+	for (int32_t i = 0; i < 4; i++)
+	std::cout << *((*ArrPtr)+i) << ", " << std::flush;
+   }
+
+   void add_8_components_2(float32x4_t x, float32x4_t y) {
+	   //std::cout << "Naveen: Inside L2<8> add_8_components_2" << std::flush;
+           float32x4_t tmp = vsubq_f32(y, x);
+           accu8 = vaddq_f32(accu8, vmulq_f32(tmp, tmp));
+   }
+
+   float result_8() {
+	   //std::cout << "Naveen: Inside L2<8> result_8" << std::flush;
+	   float32x4_t sum = vpaddq_f32(accu8, accu8);
+	   float(*ArrPtr)[4] = (float(*)[4])&sum;
+	   std::cout << " Naveen: sum values: " << std::flush;
+	   for (int32_t i = 0; i < 4; i++)
+           std::cout << *((*ArrPtr)+i) << ", " << std::flush;		   
+          
+	   
+	   float32x4_t sum2 = vpaddq_f32(sum, sum);
+	   float(*ArrPtr1)[4] = (float(*)[4])&sum2;
+	   std::cout << " Naveen: sum2 values: " << std::flush;
+	   for (int32_t i = 0; i < 4; i++)
+           std::cout << *((*ArrPtr1)+i) << ", " << std::flush; 		   
+	   
+	   //return vgetq_lane_f32(sum2, 3) + vgetq_lane_f32(sum2, 1);
+           float f = vgetq_lane_f32(sum2, 1);
+	   std::cout << " Naveen: result_8 value: " << f << std::flush;
+	   //std::ofstream MyFile;
+	   //MyFile.open("/home/ec2-user/k-NN/compute_distance.txt", std::ios_base::app);
+	   //MyFile << f << "\n";
+	   return f;
+	   
+   }
+};
+
+#endif
+*/
+
+#ifdef __aarch64__
+template <>
+struct SimilarityL2<8> {
+	static constexpr int simdwidth = 8; 
+	    static constexpr MetricType metric_type = METRIC_L2;
+
+	    const float *y, *yi;
+	    explicit SimilarityL2(const float* y) : y(y) {}
+	         float32x4x2_t accu8;
+
+        void begin_8() {
+        accu8 = vzipq_f32(vdupq_n_f32(0.0f),vdupq_n_f32(0.0f));
+        yi = y;
+    }
+
+void add_8_components(float32x4x2_t x) {
+	    //std::cout << "Naveen: Inside L2<8> add_8_components" << std::flush;
+	    float32x4x2_t yiv = vld1q_f32_x2(yi);
+	    
+	    /*float(*ArrPtr)[8] = (float(*)[8])&yiv;
+            std::cout << " Naveen: yiv values: " << std::flush;
+            for (int32_t i = 0; i < 8; i++)
+            std::cout << *((*ArrPtr)+i) << ", " << std::flush;
+
+            float(*ArrPtr2)[8] = (float(*)[8])&x;
+	               std::cout << " Naveen: x values: " << std::flush;
+		                  for (int32_t i = 0; i < 8; i++)
+					             std::cout << *((*ArrPtr2)+i) << ", " << std::flush; 
+            */
+	    yi += 8;
+
+            float32x4_t sub0 = vsubq_f32(yiv.val[0], x.val[0]);
+	    float32x4_t sub1 = vsubq_f32(yiv.val[1], x.val[1]);
+	    
+	    float32x4_t accu8_0 = vaddq_f32(accu8.val[0], vmulq_f32(sub0,sub0));
+            float32x4_t accu8_1 = vaddq_f32(accu8.val[1], vmulq_f32(sub1,sub1));
+            float32x4x2_t accu8_temp = vzipq_f32(accu8_0, accu8_1);
+            accu8 = vuzpq_f32(accu8_temp.val[0],accu8_temp.val[1]);
+
+            /*float(*ArrPtr3)[4] = (float(*)[4])&accu8_0;
+	    std::cout << " Naveen: accu8_0 values: " << std::flush; 
+            for (int32_t i = 0; i < 4; i++)
+            std::cout << *((*ArrPtr3)+i) << ", " << std::flush;		    
+            */
+
+	    //float32x4x2_t tmp = vzipq_f32(vsubq_f32(yiv.val[0], x.val[0]), vsubq_f32(yiv.val[1], x.val[1]));
+            //float32x4x2_t tmp = vtrnq_f32(sub0,sub1);
+            /*float(*ArrPtr1)[8] = (float(*)[8])&accu8;
+	    std::cout << " Naveen: accu8 values: " << std::flush;
+	    for (int32_t i = 0; i < 8; i++)
+            std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+            */ 
+	    //accu8 = tmp;
+}
+
+void add_8_components_2(float32x4x2_t x, float32x4x2_t y) {
+     //std::cout << "Naveen: Inside L2<8> add_8_components_2" << std::flush;
+     //float32x4x2_t tmp = vzipq_f32(vsubq_f32(y.val[0], x.val[0]), vsubq_f32(y.val[1], x.val[1]));
+     float32x4_t sub0 = vsubq_f32(y.val[0], x.val[0]);
+     float32x4_t sub1 = vsubq_f32(y.val[1], x.val[1]);
+     
+     float32x4_t accu8_0 = vaddq_f32(accu8.val[0], vmulq_f32(sub0,sub0));
+     float32x4_t accu8_1 = vaddq_f32(accu8.val[1], vmulq_f32(sub1,sub1));
+     float32x4x2_t accu8_temp = vzipq_f32(accu8_0, accu8_1);
+     accu8 = vuzpq_f32(accu8_temp.val[0],accu8_temp.val[1]);
+
+}
+
+float result_8() {
+	//std::cout << "Naveen: Inside L2<8> result_8" << std::flush;
+	/*
+	float32x4x2_t sum_tmp = vzipq_f32(vpaddq_f32(accu8.val[0], accu8.val[0]), vpaddq_f32(accu8.val[1], accu8.val[1]));
+	float32x4x2_t sum = vuzpq_f32(sum_tmp.val[0], sum_tmp.val[1]);
+        float32x4x2_t sum2_tmp = vzipq_f32(vpaddq_f32(sum.val[0], sum.val[0]), vpaddq_f32(sum.val[1], sum.val[1]));          
+        float32x4x2_t sum2 = vuzpq_f32(sum2_tmp.val[0], sum2_tmp.val[1]);
+        return vgetq_lane_f32(sum2.val[0], 0) + vgetq_lane_f32(sum2.val[1], 0);
+        */
+	
+        float32x4_t sum_0 = vpaddq_f32(accu8.val[0], accu8.val[0]);
+	float32x4_t sum_1 = vpaddq_f32(accu8.val[1], accu8.val[1]);
+	float32x4_t sum2_0 = vpaddq_f32(sum_0, sum_0);
+	float32x4_t sum2_1 = vpaddq_f32(sum_1, sum_1);
+	return vgetq_lane_f32(sum2_0, 0) + vgetq_lane_f32(sum2_1, 0);
+	//std::cout << " Naveen: Result_8 value: " << f << std::flush;
+        //return f;
+
+	/*
+        float32x4_t sum_tmp_0 = vpaddq_f32(accu8.val[0], accu8.val[0]); 
+        float32x4_t sum_tmp_1 = vpaddq_f32(accu8.val[1], accu8.val[1]);
+
+        float(*ArrPtr3)[4] = (float(*)[4])&sum_tmp_0;
+        std::cout << " Naveen: sum_tmp_0 values: " << std::flush;
+        for (int32_t i = 0; i < 4; i++) 
+             std::cout << *((*ArrPtr3)+i) << ", " << std::flush;		
+
+        float(*ArrPtr4)[4] = (float(*)[4])&sum_tmp_1;
+        std::cout << " Naveen: sum_tmp_1 values: " << std::flush;
+        for (int32_t i = 0; i < 4; i++)
+		std::cout << *((*ArrPtr4)+i) << ", " << std::flush;
+
+        float(*ArrPtr)[8] = (float(*)[8])&accu8;
+        std::cout << " Naveen: accu8 values: " << std::flush;
+        for (int32_t i = 0; i < 8; i++)
+        std::cout << *((*ArrPtr)+i) << ", " << std::flush;
+
+	float(*ArrPtr1)[8] = (float(*)[8])&sum;
+	std::cout << " Naveen: sum values: " << std::flush;
+	for (int32_t i = 0; i < 8; i++)
+        std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+	
+	float(*ArrPtr2)[8] = (float(*)[8])&sum2;
+	std::cout << " Naveen: sum2 values: " << std::flush;
+	for (int32_t i = 0; i < 8; i++)
+        std::cout << *((*ArrPtr2)+i) << ", " << std::flush;
+
+	return 0.0f;
+	*/
+}
+};
+#endif
+
+
+
+
 template <int SIMDWIDTH>
 struct SimilarityIP {};
 
@@ -762,6 +1041,60 @@ struct SimilarityIP<8> {
 };
 #endif
 
+#ifdef __aarch64__
+
+template <>
+struct SimilarityIP<8> {
+	static constexpr int simdwidth = 8;
+	static constexpr MetricType metric_type = METRIC_INNER_PRODUCT;
+
+ 	const float *y, *yi;
+
+        explicit SimilarityIP(const float* y) : y(y) {}
+        float32x4x2_t accu8;
+
+	void begin_8() {
+	     accu8 = vzipq_f32(vdupq_n_f32(0.0f),vdupq_n_f32(0.0f));
+	     yi = y;
+	}
+
+	void add_8_components(float32x4x2_t x) {
+		//std::cout << "Naveen: Inside IP<8> add_8_components" << std::flush;
+		float32x4x2_t yiv = vld1q_f32_x2(yi);
+		yi += 8;
+
+		float32x4_t accu8_0 = vaddq_f32(accu8.val[0], vmulq_f32(yiv.val[0], x.val[0]));
+		float32x4_t accu8_1 = vaddq_f32(accu8.val[1], vmulq_f32(yiv.val[1], x.val[1]));
+		float32x4x2_t accu8_temp = vzipq_f32(accu8_0, accu8_1);
+		accu8 = vuzpq_f32(accu8_temp.val[0],accu8_temp.val[1]);
+
+		  /*float(*ArrPtr1)[8] = (float(*)[8])&accu8;
+                  std::cout << " Naveen: accu8 values: " << std::flush;
+	                        for (int32_t i = 0; i < 8; i++)
+                                std::cout << *((*ArrPtr1)+i) << ", " << std::flush;
+	         */
+	}
+
+	void add_8_components_2(float32x4x2_t x1, float32x4x2_t x2) {
+		//std::cout << "Naveen: Inside IP<8> add_8_components_2" << std::flush;
+		float32x4_t accu8_0 = vaddq_f32(accu8.val[0], vmulq_f32(x1.val[0], x2.val[0]));
+		float32x4_t accu8_1 = vaddq_f32(accu8.val[1], vmulq_f32(x1.val[1], x2.val[1]));
+		float32x4x2_t accu8_temp = vzipq_f32(accu8_0, accu8_1);
+	        accu8 = vuzpq_f32(accu8_temp.val[0],accu8_temp.val[1]);
+	}
+
+	float result_8() {
+		//std::cout << "Naveen: Inside IP<8> result_8" << std::flush;
+		float32x4x2_t sum_tmp = vzipq_f32(vpaddq_f32(accu8.val[0], accu8.val[0]), vpaddq_f32(accu8.val[1], accu8.val[1]));
+		float32x4x2_t sum = vuzpq_f32(sum_tmp.val[0], sum_tmp.val[1]);
+		float32x4x2_t sum2_tmp = vzipq_f32(vpaddq_f32(sum.val[0], sum.val[0]), vpaddq_f32(sum.val[1], sum.val[1]));
+		float32x4x2_t sum2 = vuzpq_f32(sum2_tmp.val[0], sum2_tmp.val[1]);
+		return vgetq_lane_f32(sum2.val[0], 0) + vgetq_lane_f32(sum2.val[1], 0);
+	}
+};
+#endif
+
+
 /*******************************************************************
  * DistanceComputer: combines a similarity and a quantizer to do
  * code-to-vector or code-to-code comparisons
@@ -858,12 +1191,121 @@ struct DCTemplate<Quantizer, Similarity, 8> : SQDistanceComputer {
     }
 
     float query_to_code(const uint8_t* code) const final {
-        return compute_distance(q, code);
+	    return compute_distance(q, code);
     }
 };
 
 #endif
 
+/*
+#ifdef __aarch64__
+
+template <class Quantizer, class Similarity>
+struct DCTemplate<Quantizer, Similarity, 8> : SQDistanceComputer {
+	using Sim = Similarity;
+	Quantizer quant;
+
+	DCTemplate(size_t d, const std::vector<float>& trained)
+		 : quant(d, trained) {}
+
+	float compute_distance(const float* x, const uint8_t* code) const {
+		//std::cout << "Naveen: Inside compute_distance" << std::flush;
+		Similarity sim(x);
+		sim.begin_8();
+		for (size_t i = 0; i < quant.d; i += 4) {
+			float32x4_t xi = quant.reconstruct_8_components(code, i);
+			float(*ArrPtr)[4] = (float(*)[4])&xi;
+			std::cout << " Naveen:  Extracted reconstruct_8_component values: " << std::flush;
+			for (int32_t i = 0; i < 4; i++)
+			std::cout << *((*ArrPtr)+i) << ", " << std::flush;	
+			sim.add_8_components(xi);
+		}
+		return sim.result_8();
+	}
+
+	float compute_code_distance(const uint8_t* code1, const uint8_t* code2)
+		const {
+			//std::cout << "Naveen: Inside compute_code_distance" << std::flush;
+			Similarity sim(nullptr);
+			sim.begin_8();
+			for (size_t i = 0; i < quant.d; i += 8) {
+				float32x4_t x1 = quant.reconstruct_8_components(code1, i);
+				float32x4_t x2 = quant.reconstruct_8_components(code2, i);
+				sim.add_8_components_2(x1, x2);
+			}
+			return sim.result_8();
+		}
+
+	void set_query(const float* x) final {
+		q = x;
+	}
+
+	float symmetric_dis(idx_t i, idx_t j) override {
+		//std::cout << "Naveen: Inside symmetric_dis" << std::flush;
+		return compute_code_distance(
+				codes + i * code_size, codes + j * code_size);
+	}
+
+	float query_to_code(const uint8_t* code) const final {
+		//std::cout << "Naveen: Inside query_to_code" << std::flush;
+		return compute_distance(q, code);
+	}
+};
+
+#endif
+*/
+
+#ifdef __aarch64__
+
+template <class Quantizer, class Similarity>
+struct DCTemplate<Quantizer, Similarity, 8> : SQDistanceComputer {
+	using Sim = Similarity;
+
+	    Quantizer quant;
+
+	        DCTemplate(size_t d, const std::vector<float>& trained)
+			            : quant(d, trained) {}
+		float compute_distance(const float* x, const uint8_t* code) const {
+	               //std::cout << "Naveen: Inside compute_distance" << std::flush;
+	               Similarity sim(x);
+		       sim.begin_8();
+		       for (size_t i = 0; i < quant.d; i += 8) {
+			                   float32x4x2_t xi = quant.reconstruct_8_components(code, i);
+					               sim.add_8_components(xi);
+						               }
+		       return sim.result_8();
+		}
+
+		float compute_code_distance(const uint8_t* code1, const uint8_t* code2)
+			            const {
+					    //std::cout << "Naveen: Inside compute_code_distance" << std::flush;
+					    Similarity sim(nullptr);
+					    sim.begin_8();
+					    for (size_t i = 0; i < quant.d; i += 8) {
+						    float32x4x2_t x1 = quant.reconstruct_8_components(code1, i);
+						    float32x4x2_t x2 = quant.reconstruct_8_components(code2, i);
+						    sim.add_8_components_2(x1, x2);
+					    }
+					    return sim.result_8();
+				    }
+		void set_query(const float* x) final {
+			        q = x;
+				    }
+
+		float symmetric_dis(idx_t i, idx_t j) override {
+			    //std::cout << "Naveen: Inside symmetric_dis" << std::flush;
+			            return compute_code_distance(
+						                    codes + i * code_size, codes + j * code_size);
+				        }
+		float query_to_code(const uint8_t* code) const final {
+			    //std::cout << "Naveen: Inside query_to_code" << std::flush;
+			            return compute_distance(q, code);
+				        }
+};
+#endif
+
+
+
 /*******************************************************************
  * DistanceComputerByte: computes distances in the integer domain
  *******************************************************************/
@@ -985,55 +1427,58 @@ struct DistanceComputerByte<Similarity, 8> : SQDistanceComputer {
  * specialization
  *******************************************************************/
 
-template <class Sim>
+template <class Sim, class Sim_default>
 SQDistanceComputer* select_distance_computer(
         QuantizerType qtype,
         size_t d,
         const std::vector<float>& trained) {
     constexpr int SIMDWIDTH = Sim::simdwidth;
+    constexpr int SIMDWIDTH_DEFAULT = Sim_default::simdwidth;
     switch (qtype) {
         case ScalarQuantizer::QT_8bit_uniform:
             return new DCTemplate<
-                    QuantizerTemplate<Codec8bit, true, SIMDWIDTH>,
-                    Sim,
-                    SIMDWIDTH>(d, trained);
+                    QuantizerTemplate<Codec8bit, true, SIMDWIDTH_DEFAULT>,
+                    Sim_default,
+                    SIMDWIDTH_DEFAULT>(d, trained);
 
         case ScalarQuantizer::QT_4bit_uniform:
             return new DCTemplate<
-                    QuantizerTemplate<Codec4bit, true, SIMDWIDTH>,
-                    Sim,
-                    SIMDWIDTH>(d, trained);
+                    QuantizerTemplate<Codec4bit, true, SIMDWIDTH_DEFAULT>,
+                    Sim_default,
+                    SIMDWIDTH_DEFAULT>(d, trained);
 
         case ScalarQuantizer::QT_8bit:
             return new DCTemplate<
-                    QuantizerTemplate<Codec8bit, false, SIMDWIDTH>,
-                    Sim,
-                    SIMDWIDTH>(d, trained);
+                    QuantizerTemplate<Codec8bit, false, SIMDWIDTH_DEFAULT>,
+                    Sim_default,
+                    SIMDWIDTH_DEFAULT>(d, trained);
 
         case ScalarQuantizer::QT_6bit:
             return new DCTemplate<
-                    QuantizerTemplate<Codec6bit, false, SIMDWIDTH>,
-                    Sim,
-                    SIMDWIDTH>(d, trained);
-
+                    QuantizerTemplate<Codec6bit, false, SIMDWIDTH_DEFAULT>,
+                    Sim_default,
+                    SIMDWIDTH_DEFAULT>(d, trained);
+        		    
         case ScalarQuantizer::QT_4bit:
             return new DCTemplate<
-                    QuantizerTemplate<Codec4bit, false, SIMDWIDTH>,
-                    Sim,
-                    SIMDWIDTH>(d, trained);
+                    QuantizerTemplate<Codec4bit, false, SIMDWIDTH_DEFAULT>,
+                    Sim_default,
+                    SIMDWIDTH_DEFAULT>(d, trained);
 
+        		    
         case ScalarQuantizer::QT_fp16:
+	    //std::cout << "Naveen: Inside QT_fp16 switch case 2" << std::flush;
             return new DCTemplate<QuantizerFP16<SIMDWIDTH>, Sim, SIMDWIDTH>(
                     d, trained);
 
         case ScalarQuantizer::QT_8bit_direct:
             if (d % 16 == 0) {
-                return new DistanceComputerByte<Sim, SIMDWIDTH>(d, trained);
+                return new DistanceComputerByte<Sim_default, SIMDWIDTH_DEFAULT>(d, trained);
             } else {
                 return new DCTemplate<
-                        Quantizer8bitDirect<SIMDWIDTH>,
-                        Sim,
-                        SIMDWIDTH>(d, trained);
+                        Quantizer8bitDirect<SIMDWIDTH_DEFAULT>,
+                        Sim_default,
+                        SIMDWIDTH_DEFAULT>(d, trained);
             }
     }
     FAISS_THROW_MSG("unknown qtype");
@@ -1142,18 +1587,34 @@ void ScalarQuantizer::train_residual(
 }
 
 ScalarQuantizer::SQuantizer* ScalarQuantizer::select_quantizer() const {
-#ifdef USE_F16C
+if (d % 8 == 0) {
+   #if defined(USE_F16C)
+        return select_quantizer_1<8,8>(qtype, d, trained);
+   #elif defined(__aarch64__)
+	std::cout << "Naveen: Inside if of select_quantizer 3" << std::flush;
+	return select_quantizer_1<8,1>(qtype, d, trained);       
+   #endif
+} else
+{
+	return select_quantizer_1<1,1>(qtype, d, trained);
+}
+	/*
+#if defined(USE_F16C) || defined(__aarch64__)
     if (d % 8 == 0) {
+	//std::cout << "Naveen: Inside if of select_quantizer 3" << std::flush;    
         return select_quantizer_1<8>(qtype, d, trained);
     } else
 #endif
     {
+	    //std::cout << "Naveen: Inside else of select_quantizer 3" << std::flush;    
         return select_quantizer_1<1>(qtype, d, trained);
     }
+    */
 }
 
 void ScalarQuantizer::compute_codes(const float* x, uint8_t* codes, size_t n)
-        const {
+        const {		
+    //std::cout << "Naveen: Inside compute_codes 3" << std::flush;		
     std::unique_ptr<SQuantizer> squant(select_quantizer());
 
     memset(codes, 0, code_size * n);
@@ -1173,9 +1634,37 @@ void ScalarQuantizer::decode(const uint8_t* codes, float* x, size_t n) const {
 SQDistanceComputer* ScalarQuantizer::get_distance_computer(
         MetricType metric) const {
     FAISS_THROW_IF_NOT(metric == METRIC_L2 || metric == METRIC_INNER_PRODUCT);
-#ifdef USE_F16C
     if (d % 8 == 0) {
-        if (metric == METRIC_L2) {
+	    if (metric == METRIC_L2) {
+                    #if defined(USE_F16C)
+                        return select_distance_computer<SimilarityL2<8>,SimilarityL2<8>>(qtype, d, trained); 
+                    #elif defined(__aarch64__)
+                        return select_distance_computer<SimilarityL2<8>,SimilarityL2<1>>(qtype, d, trained);
+                    #endif			
+	    } else {
+                #if defined(USE_F16C)
+		    return select_distance_computer<SimilarityIP<8>,SimilarityIP<8>>(qtype, d, trained);
+                #elif defined(__aarch64__)    
+                    return select_distance_computer<SimilarityIP<8>,SimilarityIP<1>>(qtype, d, trained);
+                #endif
+	    }
+    } else
+    {
+	    if (metric == METRIC_L2) {
+		    return select_distance_computer<SimilarityL2<1>,SimilarityL2<1>>(qtype, d, trained);
+	    } else {
+		    return select_distance_computer<SimilarityIP<1>,SimilarityIP<1>>(qtype, d, trained);
+	    }
+    }
+}
+ 
+
+
+/*
+#if defined(USE_F16C) || defined(__aarch64__)
+    if (d % 8 == 0) {
+	//std::cout << "Naveen: Inside if of get_distance_computer3" << std::flush;    
+        if (metric == METRIC_L2) {		
             return select_distance_computer<SimilarityL2<8>>(qtype, d, trained);
         } else {
             return select_distance_computer<SimilarityIP<8>>(qtype, d, trained);
@@ -1183,13 +1672,15 @@ SQDistanceComputer* ScalarQuantizer::get_distance_computer(
     } else
 #endif
     {
-        if (metric == METRIC_L2) {
+	//std::cout << "Naveen: Inside else of get_distance_computer3" << std::flush;
+	if (metric == METRIC_L2) {
             return select_distance_computer<SimilarityL2<1>>(qtype, d, trained);
         } else {
             return select_distance_computer<SimilarityIP<1>>(qtype, d, trained);
         }
     }
 }
+*/
 
 /*******************************************************************
  * IndexScalarQuantizer/IndexIVFScalarQuantizer scanner object
